<?php

namespace NodePub\Navigation;

class SitemapCache
{
    protected $cacheFile;
  
    function __construct($cacheFile)
    {
        $this->cacheFile = $cacheFile;
    }
    
    /**
     * Loads the sitemap tree from config or cache
     * If loading from config, caches the result
     *
     * @return object The TreeSitemap object
     */
    protected function load()
    {
        if (is_file($this->cacheFile) {
            return require_once($this->cacheFile);
        }
    }
  
    /**
     * Caches the serialized sitemap array by writing it to a file wrapped in a return statement.
     * 
     * @param array $serializedArray The serialized sitemap tree
     *
     * @return boolean true if ok, otherwise false
     */
    protected function cacheSerializedArray(array $serializedArray)
    {
        $data = var_export($serializedArray, true);
        $content = sprintf("<?php\n".
                         "// auto-generated by NodePub\Navigation\SitemapCache\n".
                         "// date: %s\n".
                         "return %s;\n",
                         date('Y/m/d H:i:s'), $data);
      
        return $this->writeCache($this->cacheFile, $content);
    }
  
   /**
    * Writes the given data in the cache file.
    *
    * @param string  $path    The file path
    * @param string  $data    The data to put in cache
    *
    * @return boolean true if ok, otherwise false
    */
    protected function writeCache($path, $data)
    {
        $current_umask = umask();
        umask(0000);
   
        if (!is_dir(dirname($path))) {
            // create directory structure if needed
            mkdir(dirname($path), 0777, true);
        }
        
        $tmpFile = tempnam(dirname($path), basename($path));
        
        if (!$fp = @fopen($tmpFile, 'wb')) {
            throw new \Exception(sprintf('Unable to write cache file "%s".', $tmpFile));
        }
   
        fwrite($fp, $data);
        fclose($fp);
   
        // Hack from Agavi (http://trac.agavi.org/changeset/3979)
        // With php < 5.2.6 on win32, renaming to an already existing file doesn't work, but copy does,
        // so we simply assume that when rename() fails that we are on win32 and try to use copy()
        if (!rename($tmpFile, $path)) {
            if (copy($tmpFile, $path)) {
                unlink($tmpFile);
            }
        }

        chmod($path, 0666);
        umask($current_umask);
   
        return true;
    }
}
